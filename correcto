// ejercicio 1 Entendiendo interrupciones

#include <p33FJ32MC202.h>
#include "config.h"

// -----------------------------------------------------------------------------


static int ticks1=0; //Variables que podemos usar en el main y en la interrupción
static int ticks2=0;
static int periodo;

int main (void){
inicializarReloj();
AD1PCFGL=0xFFFF; //Pines digitales

//salidas
TRISB&= 0x3FFF;// Salidas los leds 15 y 14
//Entradas 
TRISB|=(1<<2);
//Leds inicialmente apagados
PORTB|=0xC000;

//Configuramos timer
T1CON=0x0030; //escogemos preescalado 3
PR1=39062;
TMR1=0; //Inicia la cuenta desde 0.
IFS0bits.T1IF=0; // Pongo bandera a 0
IEC0bits.T1IE=1;// Habilito interrupción
IPC0bits.T1IP=3; // prioridad 3
T1CON|=(1<<15); //Comienza el timer 1

int pulsador=1; //pulsador sin pulsar
int pulsador_ant; //Para detectar el flanco
int pulso=0;

while(1){ 
    
pulsador_ant=pulsador;
pulsador=(PORTB>>2)&(0x0001);
if(pulsador<pulsador_ant){
pulso++;
//Condición para que empiecen a la vez
ticks1=0;
ticks2=0;
TMR1=0;
PORTB|=((1<<15)|(1<<14));}

if(pulso%2==0){
periodo=2;
}
else{
periodo=10;
}
if(ticks1<periodo){
PORTB&=~(1<<14);
}
else{
PORTB|=(1<<14);}

if(ticks2<5){
PORTB&=~(1<<15);
}
else {
PORTB|=(1<<15);
}
}
return 0;
}

void __attribute__((interrupt,no_auto_psv))
_T1Interrupt(void){

IFS0bits.T1IF=0;//ponemos bandera a 0

ticks1++;
if(ticks1>=(periodo*2)){
ticks1=0;
}
ticks2++;
if(ticks2>19){
ticks2=0;
}

}



// EJERCICIO 2 EJERCITANDO LA CAPACIDAD DE CREACIÓN


//CABECERA timer.h

#ifndef _TIMER_H
#define _TIMER_H

void inicializarTimer(unsigned int ms);

#endif


// Cuerpo de la función timer.c

#include <p33FJ32MC202.h>
#include "config.h"

void inicializarTimer (unsigned int dms){

if( dms<=16){
T1CON=0x0000;
PR1=dms*(FCY/10000);
}

else if(dms<=132){
T1CON=0x0010;
PR1=dms*(FCY/80000);
}

else if (dms<=1058){
T1CON=0x0020;
PR1=dms*(FCY/640000);
}

else if(dms<=4235){
T1CON=0x0030;
PR1=dms*(FCY/2560000);
}
else {
dms=4235;
T1CON=0x0030;
PR1=dms*(FCY/2560000);
}

TMR1=0;
IFS0bits.T1IF=0; // bandera a 0
IEC0bits.T1IE=1; //Habilitamos interrupción
IPC0bits.T1IP=4; // Prioridad intermedia
T1CON|=(1<<15); // Comienza a contar
}

// MAIN.C del ejercicio anterior 4.1 pero utilizando función

#include <p33FJ32MC202.h>
#include "config.h"
#include "timer.h"

// -----------------------------------------------------------------------------


static int ticks1=0; //Variables que podemos usar en el main y en la interrupción
static int ticks2=0;
static int periodo;

int main (void){
inicializarReloj();
AD1PCFGL=0xFFFF; //Pines digitales

//salidas
TRISB&= 0x3FFF; //Salidas los leds 15 y 14
//Entradas 
TRISB|=(1<<2);
//Leds inicialmente apagados
PORTB|=0xC000;

//Configuramos timer
inicializarTimer(2500);

int pulsador=1;
int pulsador_ant; //Para detectar el flanco
int pulso=0;

while(1){ 
    
pulsador_ant=pulsador;
pulsador=(PORTB>>2)&(0x0001);
if(pulsador<pulsador_ant){
pulso++;
//Condición para que empiecen a la vez
ticks1=0;
ticks2=0;
TMR1=0;
PORTB|=((1<<14)|(1<<15));}
if(pulso%2==0){
periodo=2;
}
else{
periodo=10;
}
if(ticks1<periodo){
PORTB&=~(1<<14);
}
else{
PORTB|=(1<<14);}

if(ticks2<5){
PORTB&=~(1<<15);
}
else {
PORTB|=(1<<15);
}
}
return 0;
}

void __attribute__((interrupt,no_auto_psv))
_T1Interrupt(void){

IFS0bits.T1IF=0;//ponemos bandera a 0


ticks1++;
if(ticks1>=(periodo*2)){
ticks1=0;
}
ticks2++;
if(ticks2>19){
ticks2=0;
}

}














//
